/**
*****************************************************************************
**
**  File        : sysmem.c
**
**  Author	    : Auto-generated by STM32CubeIDE
**
**  Abstract    : STM32CubeIDE Minimal System Memory calls file
**
** 		          For more information about which c-functions
**                need which of these lowlevel functions
**                please consult the Newlib libc-manual
**
**  Environment : STM32CubeIDE MCU
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
*****************************************************************************
**
** <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
**
** Redistribution and use in source and binary forms, with or without modification,
** are permitted provided that the following conditions are met:
**   1. Redistributions of source code must retain the above copyright notice,
**      this list of conditions and the following disclaimer.
**   2. Redistributions in binary form must reproduce the above copyright notice,
**      this list of conditions and the following disclaimer in the documentation
**      and/or other materials provided with the distribution.
**   3. Neither the name of STMicroelectronics nor the names of its contributors
**      may be used to endorse or promote products derived from this software
**      without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
** OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**
*****************************************************************************
*/

///* Includes */
//#include <errno.h>
//#include <stdio.h>
//
///* Variables */
//extern int errno;
//register char * stack_ptr asm("sp");
//
///* Functions */
//
///**
// _sbrk
// Increase program data space. Malloc and related functions depend on this
//**/
//caddr_t _sbrk(int incr)
//{
//	extern char end asm("end");
//	static char *heap_end;
//	char *prev_heap_end;
//
//	if (heap_end == 0)
//		heap_end = &end;
//
//	prev_heap_end = heap_end;
//	// TODO: add error handling
//	/*if (heap_end + incr > stack_ptr)
//	{
//		errno = ENOMEM;
//		return (caddr_t) -1;
//	}*/
//
//	heap_end += incr;
//
//	return (caddr_t) prev_heap_end;
//}


/*
 * sbrk.c
 *
 * This code written July 2018 by Chuck McManis (cmcmanis@mcmanis.com)
 * it may be freely used, reused, and modified with our without accrediting the
 * author.
 *
 * This implements a larger heap than you get by default
 * in newlib. It uses the RAM between the end of the declared
 * data and the bottom of the "largest" stack for the heap.
 *
 * The only user interface to this code is the weakly bound
 * local_heap_setup() which is called the first time malloc
 * has to get more memory for the heap. This function passes
 * pointers to its two controls, the start address and end
 * address of the heap. Once called those are not changed.
 *
 * If the user does not define local_heap_setup in their code,
 * the RAM between _ebss and _stack - MAX_STACK_SIZE is used
 * for the heap. Typically this is RAM that is internal to the
 * SoC.
 *
 * On other processors, additional ram might become available
 * after reset and some peripheral setup (like PSRAM or SDRAM
 * on parts with the FMC peripheral). In that case the user
 * can define their own function local_heap_setup and put
 * the start and end address of heap into that external RAM.
 *
 * Note that memory MUST be contiguous between the start and
 * end point of the heap. If there are gaps in that memory
 * then malloc() will hard fault when it tries to use
 * memory from the gap.
 */
#include <stdint.h>
#include <errno.h>
#include <malloc.h>

#define MAX_STACK_SIZE  8192

void local_heap_setup(uint8_t **start, uint8_t **end);

#pragma weak local_heap_setup = __local_ram

/* these are defined by the linker script */
extern uint8_t _ebss, _stack;

static uint8_t *_cur_brk = NULL;
static uint8_t *_heap_end = NULL;

/*
 * If not overridden, this puts the heap into the left
 * over ram between the BSS section and the stack while
 * preserving MAX_STACK_SIZE bytes for the stack itself.
 */
static void
__local_ram(uint8_t **start, uint8_t **end)
{
    *start = &_ebss;
    *end = *start + 1024 * 5;//(uint8_t *)(&_stack - MAX_STACK_SIZE);
}


/* prototype to make gcc happy */
void *_sbrk_r(struct _reent *, ptrdiff_t );

void *_sbrk_r(struct _reent *reent, ptrdiff_t diff)
{
    uint8_t *_old_brk;

    if (_heap_end == NULL) {
        local_heap_setup(&_cur_brk, &_heap_end);
    }

    _old_brk = _cur_brk;
    if (_cur_brk + diff > _heap_end) {
        reent->_errno = ENOMEM;
        return (void *)-1;
    }
    _cur_brk += diff;
    return _old_brk;
}

